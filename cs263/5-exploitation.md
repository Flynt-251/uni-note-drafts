# 5 - Exploitation

If we're exploiting something, we're using that thing to our advantage, usually in a way that's not intended. You probably already know what an exploit is, in terms of security: usually it's some bug or feature, which can be abused to break the Confidentiality, Integrity and/or Availability of a system. Exploits can be a range of things, from reversing an encryption algorithm, to modding a current-gen console, to performing a DDoS attack.

Some exploits can prove to be just an entry point: we need to do more work in order to breach a system, like find a way to gain elevated privileges or access sensitive data. If we identify a vulnerability, and can use it to do such things, then it becomes an exploit, and could expose further vulnerabilities. Exploits then inherently bring **risk**: if an attacker uses an exploit, how easy is it to pull off, and what's the potential damage?

Let's use an example. The launch of the Nintendo Switch saw great market success, and its new hardware quickly became a target for hackers, who wanted to either develop their own homebrew games, run custom software such as emulators, or just pirate games. After about a year, an exploit was made public, which was inherent to the Nvidia Tegra X1 chip that the system runs on: a chip designed to be fairly open. Using just a paper clip, it was easy to run the console in a "debug mode" and apply an unauthorised patch. This led to a few million consoles becoming easy to exploit, but Nintendo later put out a hardware revision which made the exploit significantly harder. It's still possible to do on any switch, but on later, more ubiquitous models, it's way harder, so Nintendo *mitigated* the risk here.

## Should I use an exploit?

Well, no, unless you're willing to accept any consequences that go along with it. At best, you'll go unnoticed, but at worst, you'll be charged under the Computer Misuse Act or Computer Fraud and Abuse Act and/or get sued by your target.

Let's answer that again in the context of penetration testing. First, check what you'll be accessing in order to carry out the exploit: if it's hardware or services which have not been allowed in your agreement, don't use the exploit, but you can always mention it in your report and propose further testing. Otherwise, consider its impact: not all exploits will expose further vulnerabilities, so you should prioritise the ones that do, as well as the ones that incur the most significant risk, i.e. those that will cause significant damage and are easy to perform.

Now let's have some fun and look at some types of exploits.

## Explute Compute

There are two types of **computer exploits**, known and unknown, otherwise called **day zero exploits**.

A known exploit is one that is already documented, typically under the [CVE List](https://www.cve.org/). You can look up a keyword, such as "Windows" or "FTP" and get a list of relevant exploits, which can be very useful in starting to assess the security of a system. Known exploits can be found in older versions of software, so if you notice an out-of-date software version when testing, it's worth looking into known exploits. Even up-to-date versions may not have known exploits fully patched.

A day zero exploit is undocumented, and unidentified. The example we gave above is a day zero exploit. These exploits will take some time to identify and fully utilise, usually cyber security experts will take a significant amount of time researching a particular exploit before documenting it. Depending on the severity and approach for the exploit, zero day exploits can take months to fix.

We can then combine a series of exploits to gain access to a system and fully compromise it. This is called an **exploit kit**, and these are often delivered through a web page. Some example kits include Angler, Rig and Fallout.

## She sells seashells on the sea shore

The **shell** of a computer is the interface provided by an operating system to provide access to the system, usually a command line interface or GUI. An attacker will typically use a shell as a payload when attacking a system to allow them access to all parts, much like how you would use a command shell such as bash.

### Bind Shell

A bind shell describes the case where a victim listens for a response on a certain IP address and port number. The attacker can then connect to this location, and the victim will send a shell prompt. This allows the attacker access to a shell to perform whatever actions they wish. This can generally be prevented by using a firewall and blocking suspect incoming connections.

### Reverse Shell

Reverse shells are typically more successful than bind shells, as they work in the opposite way: the attacker listens on a port for the victim to connect to, and the victim will then send a shell prompt. Because the victim initiates the conversation, the firewall is less likely to block the connection.

### Web Shell

Let's say we've hacked into a web server, what can we do? We can set up a **web shell** to let us do whatever we want, such as harvest sensitive data such as logins, upload malware to multiple computers, and deface websites. Web shells are scripts that perform each of the following tasks, all in one:

- **Set up persistent remote access** - This lets us connect to the web server whenever we want, and can prevent search engines from blacklisting the website where the web shell has been placed.
- **Gain Root Privileges** - The shell will then use a series of other exploits to gain root privileges, thereby giving us full control.
- **Pivot and launch attack** - Scan the rest of the local network to identify other hosts, firewalls, and so on. Pivoting lets us keep a low profile and prevents us from being easily detected, while we launch our attack.
- **Connect to a botnet** - We can then connect this server and its peers to a botnet, which can be used to share malware or perform DDoS attacks.

We can protect against web shells by repeatedly checking the integrity of our files, using File Integrity Monitoring (FIM) software, ensure we give web applications the lowest privileges possible, use intrusion protection systems, use firewalls and create subnetworks to isolate compromised components.

## Isn't this useless anyway?

Standard computing advice nowadays is to have some sort of antivirus protection. As an attacker, we want to find out how we can bypass this protection and install malware undetected, and we can first understand how to do this by knowing how antivirus programs detect malware: this is either through signature checks, which look for common malware code, or heuristics, which runs the malware in a sandbox or analyses the executable to determine if it runs harmful commands. So how can we get past Antivirus then?

- Figure out how to disable it
- Add additional code to confuse signature checks
- Encode the malware into a different format, and decode on execution
- Encrypt the malware
- Write malware directly to memory
- Split the malware so the loader and payload are ran separately
- Test the antivirus on its own to find vulnerabilities
- Use tools such as Msfvenom

